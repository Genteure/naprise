using Naprise.Service.MailKit;
using System.Reflection;
using System.Text;
using System.Text.Json;

namespace Naprise.DocGenerator;

internal class Generator
{
    private readonly string basePath;

    public Generator(string basePath)
    {
        this.basePath = basePath;
    }

    internal void Generate()
    {
        this.GenerateReadme();
        this.GenerateServiceJson();
        this.GenerateEmailPlatformJson();
    }

    private class Platform
    {
        public string? Name { get; set; }
        public string? Host { get; set; }
        public int Port { get; set; }
        public bool UseSsl { get; set; }
        public bool UserNameWithDomain { get; set; }
        public string[]? Domains { get; set; }
    }

    private void GenerateEmailPlatformJson()
    {
        var list = MailKitEmail.EmailPlatforms.GroupBy(x => x.Value).Select(x => new Platform
        {
            Name = x.Key.Name,
            Host = x.Key.Host,
            Port = x.Key.Port,
            UseSsl = x.Key.UseSsl,
            UserNameWithDomain = x.Key.UserNameWithDomain,
            Domains = x.Select(y => y.Key).ToArray()
        }).ToArray();

        var path = Path.Combine(this.basePath, "docs", "data", "email_platforms.json");
        File.WriteAllText(path, JsonSerializer.Serialize(list, new JsonSerializerOptions(JsonSerializerDefaults.Web)
        {
            WriteIndented = true
        }));
    }

    private class Service
    {
        public string? Id { get; set; }
        public string? Name { get; set; }
        public string? Format { get; set; }
        public string[]? Schemes { get; set; }
        public string? Website { get; set; }
        public string? Doc { get; set; }
    }

    private void GenerateServiceJson()
    {
        var types = new List<Type>(ServiceRegistry.DefaultServices);

        foreach (var assem in new[] { typeof(MailKitEmail).Assembly })
        {
            types.AddRange(assem.GetTypes().Where(x => x.IsPublic && typeof(INotifier).IsAssignableFrom(x)));
        }

        var list = types.OrderBy(x => x.Name).Select(t =>
        {
            var attr = t.GetCustomAttribute<NapriseNotificationServiceAttribute>()!;
            var formats = new List<string>(3);
            if (attr.SupportText)
                formats.Add("text");
            if (attr.SupportMarkdown)
                formats.Add("markdown");
            if (attr.SupportHtml)
                formats.Add("html");
            var format = string.Join(", ", formats);

            return new Service
            {
                Id = t.Name.ToLowerInvariant(),
                Name = attr.DisplayName,
                Schemes = attr.Schemes,
                Format = format,
                Website = t.GetCustomAttribute<NotificationServiceWebsiteAttribute>()?.Url ?? string.Empty,
                Doc = t.GetCustomAttribute<NotificationServiceApiDocAttribute>()?.Url ?? string.Empty,
            };
        }).ToList();

        var path = Path.Combine(this.basePath, "docs", "data", "services.json");
        File.WriteAllText(path, JsonSerializer.Serialize(list, new JsonSerializerOptions(JsonSerializerDefaults.Web)
        {
            WriteIndented = true
        }));
    }

    private void GenerateReadme()
    {
        var readme = Path.Combine(this.basePath, "README.md");
        var source = File.ReadAllText(readme);

        var generated = BuildMarkdownTable(ServiceRegistry.DefaultServices);

        generated += """

            ### Naprise.Service.MailKit

            [![Nuget Version](https://img.shields.io/nuget/v/Naprise.Service.MailKit)](https://www.nuget.org/packages/Naprise.Service.MailKit)
            [![Nuget Downloads](https://img.shields.io/nuget/dt/Naprise.Service.MailKit)](https://www.nuget.org/packages/Naprise.Service.MailKit)

            ```
            dotnet add package Naprise.Service.MailKit
            ```

            ```csharp
            Naprise.DefaultRegistry.AddMailKit();
            ```

            """;

        generated += BuildMarkdownTable(typeof(MailKitEmail).Assembly.GetTypes()
            .Where(x => x.IsPublic && typeof(INotifier).IsAssignableFrom(x))
            .ToList()); // although there is only one type, this will be useful in the future when/if more types are added

        var headerIndex = source.IndexOf("# Supported Services\n");
        var before = source.IndexOf("\n\n", headerIndex) + 2;
        var after = source.IndexOf("\n\n## ", before); // ## Compatibility

        source = source[..before] + generated + source[after..];

        File.WriteAllText(readme, source);

        static string BuildMarkdownTable(IReadOnlyList<Type> types)
        {
            var b = new StringBuilder();
            b.AppendLine("<!-- Generated by src/Naprise.DocGenerator -->\n");
            b.AppendLine("| Service | Doc | URL Scheme |");
            b.AppendLine("| ------- | --- | ---------- |");

            foreach (var t in types.OrderBy(x => x.Name))
            {
                var a = t.GetCustomAttribute<NapriseNotificationServiceAttribute>()!;

                b.Append("| [");
                b.Append(a.DisplayName);
                b.Append("](");
                b.Append(t.GetCustomAttribute<NotificationServiceWebsiteAttribute>()!.Url);
                b.Append(") | [");
                b.Append(a.DisplayName);
                b.Append("](");
                b.Append($"https://genteure.github.io/naprise/services/{t.Name.ToLowerInvariant()}");
                b.Append(") | ");
                b.Append(string.Join("<br>", a.Schemes.Select(x => $"`{x}://`")));
                b.Append(" |");
                b.AppendLine();
            }

            return b.ToString();
        }
    }
}
